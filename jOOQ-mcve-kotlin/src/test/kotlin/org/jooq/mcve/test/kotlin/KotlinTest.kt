package org.jooq.mcve.test.kotlin

import org.jooq.DSLContext
import org.jooq.Record
import org.jooq.Select
import org.jooq.conf.Settings
import org.jooq.impl.DSL
import org.jooq.mcve.custom.TestId
import org.jooq.mcve.kotlin.tables.references.TEST
import org.junit.After
import org.junit.Before
import org.junit.Test
import java.sql.DriverManager
import kotlin.test.assertEquals
import kotlin.test.assertNotNull
import kotlin.test.assertTrue

class KotlinTest {

    var connection: java.sql.Connection? = null
    var ctx: DSLContext? = null

    @Before
    fun setup() {
        connection = DriverManager.getConnection("jdbc:h2:~/jooq-mcve-kotlin-2", "sa", "")

        val settings = Settings().withReturnIdentityOnUpdatableRecord(true)
        ctx = DSL.using(connection, settings)
        ctx().delete(TEST).execute()
    }

    @After
    fun after() {
        ctx = null
        connection!!.close()
        connection = null
    }

    fun ctx(): DSLContext = ctx!!

    @Test
    fun mcveTest() {
        assertEquals(1, ctx()
            .insertInto(TEST)
            .columns(TEST.CD)
            .values(42)
            .execute()
        )

        val record = ctx().fetchOne(TEST, TEST.CD.eq(42))
        assertNotNull(record)
        assertNotNull(record.id)
    }

    @Test
    fun testInlineDatatypeWorksInRecords() {
        val newId = ctx()
            .insertInto(TEST)
            .columns(TEST.CD)
            .values(42)
            .returning(TEST.ID)
            .fetchOne(TEST.ID)

        assertNotNull(newId)
        assertTrue(newId.value > 0)

        val record = ctx().fetchOne(TEST, TEST.ID.eq(newId))
        assertNotNull(record)
        assertEquals(newId, record.id)
    }

    @Test
    fun testInlineDatatypeWorksWithCoercion() {
        val newId = ctx()
            .insertInto(TEST)
            .columns(TEST.CD)
            .values(42)
            .returning(TEST.ID)
            .fetchOne(TEST.ID)

        assertNotNull(newId)
        assertTrue(newId.value > 0)

        val record = ctx().fetchOne(TEST, TEST.ID.coerce(Int::class.java).eq(newId.value))
        assertNotNull(record)
        assertEquals(newId, record.id)
    }

    data class TestThingy(val id: TestId, val cd: Int)

    // TODO: oh, by the way, you should have these extensions for jooq-kotlin
    inline fun <reified T: Any, R: Record> Select<R>.fetchOneTyped(): T? {
        return fetchOneInto(T::class.java)
    }

    inline fun <reified T: Any, R: Record> Select<R>.fetchTyped(): List<T> {
        return fetchInto(T::class.java)
    }

    // etc...

    @Test
    fun showBugWhenFetchingIntoCustomClass() {
        val newId = ctx()
            .insertInto(TEST)
            .columns(TEST.CD)
            .values(42)
            .returning(TEST.ID)
            .fetchOne(TEST.ID)

        assertNotNull(newId)
        assertTrue(newId.value > 0)

        val thingy: TestThingy? = ctx().select(TEST.ID, TEST.CD)
            .from(TEST)
            .where(TEST.ID.coerce(Int::class.java).eq(newId.value))
            .fetchOneTyped()

        assertNotNull(thingy)
        assertEquals(42, thingy.cd) // all good
        assertEquals(newId, thingy.id) // FIXME: value is always 0
    }
}